http://suninjuly.github.io/cats.html

<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>

#post2 .title
Здесь символ # означает, что надо искать элемент с id post2,
пробел - что также нужно найти элемент-потомок,
а ., что элемент-потомок должен иметь класс со значением title.

#post2 > div.title
Здесь мы указали еще тег элемента div и уточнили,
что нужно взять элемент с тегом и классом: div.title,
который находится строго на один уровень иерархии ниже чем элемент #post2

Использование порядкового номера дочернего элемента
Еще один способ найти этот элемент:
#posts > .item:nth-child(2) > .title
Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для #posts.
Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title,
родителем которого является найденный ранее элемент .item.

Также мы можем использовать сразу несколько классов элемента, чтобы его найти.
Для этого классы записываются подряд через точку: .title.second
Или [class='title second']

1. XPath запрос всегда начинается с символа / или //
XPath запрос всегда начинается с символа / или //
Символ / аналогичен символу > в CSS-селекторе, а символ // — пробелу.

2. Символ [ ] — это команда фильтрации
Правил фильтрации очень много:

-- по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с летящим котом,
для этого можно выполнить запрос //img[@id='bullet']

-- по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом.
Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]

-- по полному совпадению текста. Да, XPath — это единственный способ найти элемент по внутреннему тексту. 
Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"]. 
Такой селектор вернет элемент, только если текст полностью совпадет. 
Здесь важно сказать, что не всегда поиск по тексту — это хорошая практика, особенно в случае мультиязычных сайтов.

-- по частичному совпадению текста или атрибута. Для этого нужна функция contains. 
Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat. 
Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. 
Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) 
и некоторые простые арифметические выражения (но вообще не стоит, наверное).
Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat",
для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']

3. Символ * — команда выбора всех элементов
Например можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"]. 
Это может быть удобно, когда мы не знаем точно тег элемента, который ищем.

4. Поиск по классу в XPath регистрозависим
Также как и в случае поиска по CSS-селектором будьте внимательными к регистру при поиске по классам: 
//div/*[@class="Jumbotron-heading"] не найдет элемент на нашей странице.

pytest -s -v -m smoke test_fixture8.py 
s выводить в консоль принты, -v (verbose, то есть подробный) - выводить полный отчёт,  -m запускать маркированные тесты.

https://gist.github.com/amatellanes/12136508b816469678c2

py.test --tb=line  # only one line per failure